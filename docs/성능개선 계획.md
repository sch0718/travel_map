# 성능개선 계획

## 0. 코드 수정 시 반드시 고려돼야 할 것.

- 지도 초기화가 무조건 제일 먼저 이뤄져야 함.
- 지도 초기화가 완료된 후 데이터를 로딩해야 함.
- 로딩하는 동안은 로딩중 화면을 보여줘야 함.
- /data/maps/*.json 파일을 모두 읽어오는 것이 아니라, 필요한 데이터만 읽어오도록 함.
- 지도 목록에 필요한 id, title, 유형(테마/여행) 정보만 별도로 캐싱해두고, 필요할 때마다 참조하도록 함.
- 화면 초기화 시 선택된 지도가 없으므로 지도 데이터는 로딩하지 않음.
- 지도 목록에서 지도 선택 시 화면 출력에 필요한 데이터만 캐싱
    - 마커 표시에 필요한 데이터만 캐싱
    - 처음엔 지도에 있는 모든 장소의 마커를 표시하고, 지도에서 지역을 이동하거나 줌 레벨이 변경될 경우 지도에 표시되는 마커만 캐싱
    - 여행지도일 경우 1일차 데이터만 캐싱하고, 다른 일차 클릭 시 해당 일차 데이터만 캐싱

## 1. 데이터 로딩 최적화

### 1.1. 데이터 요청 분산 및 지연 로딩
- 초기 로딩 시 지도 목록(id, title, 유형) 정보만 우선 로드하고 UI 렌더링 시작
- 지도 초기화 완료 후 사용자가 선택한 지도의 핵심 데이터만 우선 로딩
- 초기 표시에 필요한 장소 정보(위치, 기본 마커 정보)만 먼저 로드
- 장소별 상세 정보(설명, 리뷰, 이미지 등)는 마커 클릭 시에만 로드
- 로딩 우선순위 설정
  - 중요도 1: 지도 초기화 및 기본 마커 표시에 필요한 데이터
  - 중요도 2: 현재 화면에 표시되는 장소의 기본 정보
  - 중요도 3: 부가 정보 및 참조 데이터

### 1.2. 온디맨드 데이터 로딩
- 현재 지도 뷰포트 내 위치한 장소 데이터만 메모리에 로드
  - 뷰포트 바깥 장소는 필요시에만 로드하도록 설계
  - 줌 레벨 변경 시 적절한 상세도의 데이터만 로드
- 카테고리/테마별 필터링 적용 시 해당하는 데이터만 로드
  - 필터 변경 시 이전 데이터는 메모리에서 해제하고 새 데이터만 로드
- 여행 일정별 데이터 관리
  - 현재 선택된 일차 데이터만 완전히 로드
  - 다른 일차 데이터는 기본 위치 정보만 가볍게 유지

### 1.3. 증분 업데이트
- 지도 이동 시 새로운 영역의 데이터만 추가 로드
  - 현재 뷰포트와 이전 뷰포트의 차이 영역만 계산하여 업데이트
  - 이동 방향을 예측하여 해당 방향의 데이터를 우선 로드
- 데이터 변경 시 전체 리로드 방지
  - 여행 일정 수정 시 변경된 일차의 데이터만 다시 로드
  - 장소 정보 업데이트 시 해당 장소 객체만 갱신
- 마커 클러스터링 적용 시 클러스터 단위로 데이터 업데이트
  - 클러스터 확장/축소 시 필요한 마커 데이터만 로드/해제

### 1.4. 데이터 프리페칭
- 사용자 행동 패턴 기반 프리페칭
  - 현재 보고 있는 일차의 다음/이전 일차 데이터 미리 로드
  - 자주 함께 조회되는 장소 데이터 그룹 단위로 프리페칭
- 네트워크 상태 기반 프리페칭 전략
  - 양호한 네트워크 상태에서만 프리페칭 활성화
  - 모바일 연결 시 프리페칭 데이터량 제한
- 사용자 인터랙션 기반 프리로딩
  - 마커에 마우스 오버 시 해당 장소 상세 정보 프리로딩
  - 지도 드래그 시작 시 이동 방향 예측하여 데이터 프리로드

### 1.5. 캐시 관리 전략
- 메모리 캐시와 브라우저 스토리지 이원화
  - 자주 접근하는 데이터는 메모리 캐시에 유지
  - 대용량 데이터는 IndexedDB에 저장하여 세션 간 재사용
- 캐시 무효화 정책 수립
  - TTL(Time-To-Live) 기반 캐시 만료 설정
  - 데이터 변경 시 관련 캐시만 선택적 무효화
- 캐시 용량 관리
  - 최대 캐시 크기 설정 및 LRU(Least Recently Used) 알고리즘 적용
  - 메모리 사용량 모니터링 및 임계치 초과 시 자동 정리

### 1.6. 데이터 압축 및 최적화
- 전송 데이터 경량화
  - 불필요한 속성 제거 및 데이터 구조 단순화
  - 좌표 데이터 압축 (소수점 자릿수 최적화)
- 중복 데이터 제거
  - 공통 속성은 참조 방식으로 변경하여 데이터 중복 최소화
  - 유사 장소 정보는 템플릿화하여 차이점만 저장

## 2. 지도 초기화 최적화

### 2.1. 마커 최적화 (마커 이미지 최적화)

- 마커 이미지 스프라이트 시트 사용
  - 개별 마커 이미지를 하나의 이미지로 통합하여 HTTP 요청 수 감소
  - CSS 스프라이트 기법으로 필요한 부분만 표시
- 마커 이미지 경량화
  - WebP 등 최신 이미지 포맷 사용으로 파일 크기 축소
  - SVG 활용한 벡터 기반 마커로 크기 변경 시 품질 유지
- 마커 생성 최적화
  - 사전 정의된 마커 객체 재사용 (Object Pool 패턴)
  - 동일 유형 마커는 프로토타입 패턴으로 복제하여 생성 비용 절감
- 마커 렌더링 최적화
  - 지도 영역 밖의 마커는 렌더링 비활성화
  - 줌 레벨에 따라 마커 상세도 조절 (멀리서 볼 때는 단순화된 마커)

### 2.2. 클러스터링 최적화

- 클러스터링 알고리즘 최적화
  - 고성능 그리드 기반 클러스터링 알고리즘 사용
  - 클러스터 연산을 웹 워커로 분리하여 UI 블로킹 방지
- 클러스터 표시 최적화
  - 클러스터 영역 내 마커 수에 따른 시각적 피드백 제공
  - 애니메이션 효과 최소화하여 렌더링 부하 감소
- 동적 클러스터링 임계값
  - 디바이스 성능과 마커 수에 따라 클러스터링 임계값 자동 조정
  - 모바일 기기에서는 더 적극적인 클러스터링 적용
- 클러스터 확장/축소 최적화
  - 클러스터 확장 시 점진적으로 마커 표시 (한 번에 모두 표시하지 않음)
  - 축소 시 애니메이션 최적화로 성능 저하 방지

## 3. 지도 이벤트 처리 최적화

### 3.1. 지도 이벤트 처리 최적화

- 이벤트 디바운싱 및 쓰로틀링
  - 지도 이동, 줌, 드래그 이벤트에 쓰로틀링 적용
  - 검색, 필터링 입력에 디바운싱 적용
- 이벤트 위임 패턴 활용
  - 개별 마커에 이벤트 할당 대신 지도 컨테이너에 이벤트 위임
  - 클릭 위치 기반으로 관련 마커 판별
- 비동기 이벤트 처리
  - 무거운 이벤트 핸들러는 비동기로 처리 (Promise, setTimeout 활용)
  - 이벤트 핸들러 내 연산 집약적 작업은 웹 워커로 분리
- 터치 이벤트 최적화
  - 모바일 터치 이벤트에 passive 리스너 사용으로 스크롤 성능 향상
  - 멀티터치 제스처 인식 최적화 (핀치 줌 등)
- 이벤트 핸들러 정리
  - 불필요한 이벤트 리스너 제거로 메모리 누수 방지
  - 컴포넌트 언마운트 시 모든 이벤트 리스너 정리

### 3.2. 렌더링 최적화

- 레이어 관리
  - 변경이 잦은 요소와 정적 요소를 별도 레이어로 분리
  - 마커와 오버레이는 캔버스 레이어 활용 고려
- DOM 조작 최소화
  - 마커 정보창 등 동적 요소는 재사용하여 DOM 생성 비용 절감
  - 가상 DOM 활용하여 변경사항 일괄 처리
- 렌더링 배치 처리
  - 여러 마커 업데이트를 단일 렌더링 사이클에서 처리
  - requestAnimationFrame 활용한 렌더링 최적화
- 하드웨어 가속 활용
  - 애니메이션과 전환에 CSS transform 활용
  - 3D 변환으로 GPU 가속 유도 (translate3d, will-change)

### 3.3. 사용자 인터페이스 응답성

- 비차단 UI 업데이트
  - 무거운 데이터 처리 중에도 UI 응답성 유지
  - 작업 진행률 표시로 사용자 피드백 제공
- 지능형 로딩 인디케이터
  - 작업 예상 소요 시간에 따른 적절한 로딩 UI 선택
  - 오래 걸리는 작업은 백그라운드로 전환 옵션 제공
- 점진적 UI 업데이트
  - 콘텐츠를 중요도 순으로 점진적 표시
  - 핵심 UI 요소 먼저 렌더링 후 부가 정보 추가