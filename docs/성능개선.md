# 여행 지도 웹앱 성능 개선 계획

## 1. 성능 이슈 분석

현재 여행 지도 웹앱은 사용하면서 점점 느려지는 성능 문제가 발생하고 있습니다. 코드 분석 결과, 다음과 같은 성능 병목 현상이 식별되었습니다:

### 1.1. 주요 문제점

1. **한꺼번에 모든 데이터 로드**: 
   - 앱 초기화 시 모든 테마/여행/장소 데이터를 한 번에 로드
   - 불필요한 데이터도 미리 메모리에 적재되어 자원 낭비
   - `initData()` 함수에서 모든 맵 파일을 동시에 로드

2. **비효율적인 데이터 처리**:
   - 대량의 마커 렌더링 시 성능 저하
   - 필터링 및 검색 연산이 전체 데이터셋에 대해 수행
   - 일정/테마 전환 시 불필요한 재연산

3. **UI 반응성 저하**:
   - 데이터 처리 중 메인 스레드 차단
   - 대량의 DOM 조작으로 인한 레이아웃 재계산(리플로우) 과다 발생

### 1.2. 성능 측정 지표

성능 개선 효과를 측정하기 위해 다음 지표를 모니터링해야 합니다:

- **초기 로딩 시간**: 앱이 사용 가능한 상태가 되는 데 걸리는 시간
- **메모리 사용량**: 브라우저 메모리 사용량 추이
- **상호작용 지연시간**: 사용자 액션과 화면 업데이트 사이의 지연
- **프레임 속도(FPS)**: 렌더링 성능과 부드러운 애니메이션
- **첫 마커 표시 시간**: 지도에 첫 마커가 표시되는 데 걸리는 시간

## 2. 점진적 데이터 로딩 전략

### 2.1. 데이터 로딩 아키텍처 개선

현재의 일괄 로딩 방식에서 점진적 로딩 방식으로 전환하기 위한 전략입니다.

#### 2.1.1. 데이터 로더 모듈 리팩토링

```javascript
// 기존 코드 (data.js)
async function initData() {
    try {
        showLoading(true);
        await loadMapFiles(); // 모든 맵 파일 로드
        await loadTransportations();
        await loadLabels();
        // ... 생략 ...
    } catch (error) {
        console.error('데이터 초기화 오류:', error);
    }
}
```

```javascript
// 개선된 코드 (data.js)
async function initData() {
    try {
        showLoading(true);
        
        // 필수 메타데이터만 먼저 로드
        await loadLabels();
        await loadTransportations();
        
        // 맵 파일 목록만 스캔하여 메타데이터 구성 (실제 콘텐츠는 로드하지 않음)
        await scanMapFiles();
        
        // UI 초기화 (테마/여행 선택 옵션)
        initThemeSelector();
        
        showLoading(false);
    } catch (error) {
        console.error('데이터 초기화 오류:', error);
        showError('초기 데이터를 불러오는 중 오류가 발생했습니다.', error);
    }
}
```

#### 2.1.2. 동적 맵 파일 스캔 및 메타데이터 캐싱

```javascript
// 맵 메타데이터 캐시
const mapMetaCache = {
    themes: [],  // 테마 메타데이터 배열
    trips: [],   // 여행 메타데이터 배열
    fileMap: {}  // 파일명과 ID 매핑 객체
};

/**
 * 맵 파일을 스캔하여 메타데이터만 추출
 * 실제 장소 데이터는 로드하지 않고 파일 정보와 기본 메타데이터만 캐싱
 */
async function scanMapFiles() {
    try {
        const baseUrl = getBaseUrl();
        console.log('맵 파일 스캔 시작');
        
        // 파일 목록 가져오기 (서버에서 디렉토리 목록 제공하는 경우)
        let mapFiles = [];
        try {
            const response = await fetch(`${baseUrl}/data/maps/`);
            if (response.ok) {
                const html = await response.text();
                const fileRegex = /href="([^"]+\.json)"/g;
                let match;
                
                while ((match = fileRegex.exec(html)) !== null) {
                    mapFiles.push(match[1]);
                }
                
                if (mapFiles.length === 0) {
                    console.log('디렉토리에서 JSON 파일을 찾을 수 없습니다.');
                    // 백업 파일 목록 사용 (선택적)
                    mapFiles = getBackupFileList();
                }
            } else {
                console.log('디렉토리 목록을 가져올 수 없습니다:', response.status);
                mapFiles = getBackupFileList();
            }
        } catch (dirError) {
            console.log('디렉토리 스캔 오류:', dirError.message);
            mapFiles = getBackupFileList();
        }
        
        // 파일 메타데이터 병렬 로드 (헤더만 요청하거나 작은 샘플만 요청)
        const metaPromises = mapFiles.map(async (fileName) => {
            try {
                // 헤더만 요청하여 파일 크기 확인 (선택적)
                // 또는 Range 헤더로 파일 시작 부분만 요청하여 메타데이터 추출
                const response = await fetch(`${baseUrl}/data/maps/${fileName}`, {
                    method: 'GET',
                    headers: {
                        'Range': 'bytes=0-1024'  // 첫 1KB만 요청 (메타데이터 포함 예상)
                    }
                });
                
                if (!response.ok) return null;
                
                // 파일 시작 부분에서 메타데이터 추출
                const metaChunk = await response.json();
                
                // 최소한의 필요 정보만 추출
                const metaData = {
                    id: metaChunk.id,
                    title: metaChunk.title,
                    description: metaChunk.description || '',
                    type: metaChunk.days ? 'trip' : 'theme',
                    fileName: fileName,
                    // 장소 데이터는 로드하지 않음
                    placesCount: metaChunk.places ? metaChunk.places.length : 0
                };
                
                // 파일명과 ID 매핑 저장
                mapMetaCache.fileMap[metaChunk.id] = fileName;
                
                return metaData;
            } catch (fileError) {
                console.warn(`파일 메타데이터 로드 실패: ${fileName}`, fileError);
                return null;
            }
        });
        
        // 모든 메타데이터 로드 완료 대기
        const metaResults = await Promise.allSettled(metaPromises);
        
        // 성공적으로 로드된 메타데이터만 필터링
        const validMeta = metaResults
            .filter(result => result.status === 'fulfilled' && result.value)
            .map(result => result.value);
        
        // 테마와 여행으로 분류
        mapMetaCache.themes = validMeta.filter(meta => meta.type === 'theme');
        mapMetaCache.trips = validMeta.filter(meta => meta.type === 'trip');
        
        // 데이터 스토어에 메타데이터 복사
        dataStore.themeIndex = [...mapMetaCache.themes];
        dataStore.tripIndex = [...mapMetaCache.trips];
        
        console.log('맵 메타데이터 로드 완료:', {
            themes: mapMetaCache.themes.length,
            trips: mapMetaCache.trips.length,
            total: validMeta.length
        });
        
        return {
            themes: mapMetaCache.themes,
            trips: mapMetaCache.trips
        };
    } catch (error) {
        console.error('맵 메타데이터 스캔 오류:', error);
        throw error;
    }
}

/**
 * 백업 파일 목록 반환 (선택적)
 * 서버가 디렉토리 목록을 제공하지 않을 경우 대체 방법
 */
function getBackupFileList() {
    // 미리 알고 있는 파일 목록이나 명명 규칙 기반 추측
    console.log('백업 파일 목록 사용');
    
    // 예: 미리 알려진 파일 목록
    return [
        'theme_1.json', 
        'theme_2.json', 
        'trip_1.json',
        'trip_2.json'
    ];
    
    // 또는 파일명 패턴 기반 추측
    // const filePatterns = [];
    // for (let i = 1; i <= 10; i++) {
    //     filePatterns.push(`theme_${i}.json`);
    //     filePatterns.push(`trip_${i}.json`);
    // }
    // return filePatterns;
}
```

#### 2.1.3. 개별 테마/여행 데이터 로딩

```javascript
async function loadThemeData(themeId) {
    if (dataStore.themes && dataStore.themes.find(t => t.id === themeId)) {
        console.log(`테마 데이터 이미 로드됨: ${themeId}`);
        return getThemeById(themeId);
    }
    
    try {
        showLoading(true);
        const baseUrl = getBaseUrl();
        
        // mapMetaCache에서 파일명 찾기
        const fileName = mapMetaCache.fileMap[themeId] || `theme_${themeId}.json`;
        
        const response = await fetch(`${baseUrl}/data/maps/${fileName}`);
        
        if (!response.ok) throw new Error(`테마 데이터를 로드할 수 없습니다: ${themeId}`);
        
        const themeData = await response.json();
        
        // 테마 데이터 처리 및 저장
        if (!dataStore.themes) dataStore.themes = [];
        if (!dataStore.places) dataStore.places = [];
        
        // 중복 방지를 위해 기존 테마 제거
        dataStore.themes = dataStore.themes.filter(t => t.id !== themeId);
        
        // 새 테마 추가
        dataStore.themes.push(themeData);
        
        // 테마에 포함된 장소 데이터 처리
        processPlaces(themeData.places || []);
        
        console.log(`테마 데이터 로드 완료: ${themeId}`);
        showLoading(false);
        return themeData;
    } catch (error) {
        console.error(`테마 데이터 로드 오류: ${themeId}`, error);
        showError(`테마 데이터를 불러오는 중 오류가 발생했습니다: ${themeId}`, error);
        showLoading(false);
        throw error;
    }
}
```

유사한 방식으로 `loadTripData(tripId)` 함수도 구현합니다.

### 2.2. 데이터 캐싱 전략

메모리 효율성과 성능을 개선하기 위한 캐싱 전략을 구현합니다.

#### 2.2.1. 메모리 캐시 관리

```javascript
// 데이터 캐시 관리 모듈
const dataCache = {
    // 현재 캐시된 테마/여행 ID 추적
    cachedThemes: new Set(),
    cachedTrips: new Set(),
    
    // 최대 캐시 크기 (동시에 메모리에 유지할 테마/여행 수)
    maxCacheSize: 5,
    
    // 캐시 적용
    cacheTheme(themeId, themeData) {
        if (this.cachedThemes.size >= this.maxCacheSize) {
            this.evictLeastRecentTheme();
        }
        this.cachedThemes.add(themeId);
        return themeData;
    },
    
    // 가장 오래된 테마 제거
    evictLeastRecentTheme() {
        if (this.cachedThemes.size === 0) return;
        
        // LRU 정책: 가장 오래 사용되지 않은 테마 제거
        const oldestThemeId = Array.from(this.cachedThemes)[0];
        this.cachedThemes.delete(oldestThemeId);
        
        // 테마 데이터에서 해당 테마만 제거 (연결된 장소는 유지)
        if (dataStore.themes) {
            dataStore.themes = dataStore.themes.filter(t => t.id !== oldestThemeId);
        }
        
        console.log(`캐시에서 테마 제거됨: ${oldestThemeId}`);
    },
    
    // 유사한 방식으로 Trip 캐시 관리 메서드 구현...
    
    // 캐시 히트 여부 확인
    isThemeCached(themeId) {
        return this.cachedThemes.has(themeId);
    }
};
```

#### 2.2.2. 로컬 스토리지 캐싱 (선택적)

```javascript
const localStorageCache = {
    // 로컬 스토리지 캐시 키 접두사
    prefix: 'travelmap_',
    
    // 캐시 만료 시간 (24시간)
    expiryTime: 24 * 60 * 60 * 1000,
    
    // 데이터 캐싱
    setItem(key, data) {
        try {
            const item = {
                data,
                timestamp: Date.now()
            };
            localStorage.setItem(`${this.prefix}${key}`, JSON.stringify(item));
            return true;
        } catch (error) {
            console.warn('로컬 스토리지 캐싱 실패:', error);
            return false;
        }
    },
    
    // 캐시된 데이터 가져오기
    getItem(key) {
        try {
            const item = localStorage.getItem(`${this.prefix}${key}`);
            if (!item) return null;
            
            const parsedItem = JSON.parse(item);
            
            // 캐시 만료 확인
            if (Date.now() - parsedItem.timestamp > this.expiryTime) {
                this.removeItem(key);
                return null;
            }
            
            return parsedItem.data;
        } catch (error) {
            console.warn('로컬 스토리지 조회 실패:', error);
            return null;
        }
    },
    
    // 캐시 삭제
    removeItem(key) {
        localStorage.removeItem(`${this.prefix}${key}`);
    }
};
```

## 3. 지도 렌더링 최적화

### 3.1. 마커 클러스터링 구현

많은 수의 마커가 있을 때 성능을 개선하기 위해 클러스터링을 구현합니다.

```javascript
let markerClusterer = null;

function initMarkerClusterer() {
    if (!kakao.maps.MarkerClusterer) {
        console.warn('MarkerClusterer 라이브러리가 로드되지 않았습니다.');
        return;
    }
    
    markerClusterer = new kakao.maps.MarkerClusterer({
        map: map,
        averageCenter: true,
        minLevel: 6,  // 클러스터링 시작 줌 레벨
        calculator: [10, 30, 50],  // 클러스터 크기별 마커 개수
        styles: [
            {
                width: '36px', height: '36px',
                background: 'rgba(66, 133, 244, 0.8)',
                borderRadius: '18px',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '36px'
            },
            {
                width: '48px', height: '48px',
                background: 'rgba(52, 168, 83, 0.8)',
                borderRadius: '24px',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '48px'
            },
            {
                width: '60px', height: '60px',
                background: 'rgba(251, 188, 5, 0.8)',
                borderRadius: '30px',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '60px'
            },
            {
                width: '72px', height: '72px',
                background: 'rgba(234, 67, 53, 0.8)',
                borderRadius: '36px',
                color: '#fff',
                textAlign: 'center',
                lineHeight: '72px'
            }
        ]
    });
}

function updateMapMarkers(places, trip = null) {
    // 기존 마커 제거
    removeAllMarkers();
    
    // 마커가 없으면 종료
    if (!places || places.length === 0) {
        console.log('표시할 장소가 없습니다.');
        return;
    }
    
    // 마커 클러스터러가 없으면 초기화
    if (!markerClusterer) {
        initMarkerClusterer();
    }
    
    // 마커 배열 준비
    const newMarkers = [];
    
    // 장소별 마커 생성
    places.forEach(place => {
        const marker = addMarker(place, trip);
        if (marker) newMarkers.push(marker);
    });
    
    // 마커 클러스터러에 마커 추가
    if (markerClusterer) {
        markerClusterer.clear();
        markerClusterer.addMarkers(newMarkers.filter(m => m instanceof kakao.maps.Marker));
    }
    
    // 모든 마커가 보이도록 지도 영역 설정
    setMapBounds(places);
}
```

### 3.2. 지연 렌더링(Lazy Rendering) 구현

사용자의 시야에 들어오는 영역의 데이터만 우선적으로 렌더링합니다.

```javascript
function updatePlacesList(places, trip = null) {
    // 컨테이너 초기화
    placesList.innerHTML = '';
    
    // 장소가 없을 경우 메시지 표시
    if (!places || places.length === 0) {
        placesList.innerHTML = '<div class="no-places">표시할 장소가 없습니다.</div>';
        return;
    }
    
    // 장소 데이터 기반 목록 아이템 생성
    const fragment = document.createDocumentFragment();
    const visiblePlacesCount = Math.min(places.length, 50); // 최초 50개만 렌더링
    
    // 첫 50개 항목 즉시 렌더링
    for (let i = 0; i < visiblePlacesCount; i++) {
        const listItem = createPlaceListItem(places[i], trip);
        fragment.appendChild(listItem);
    }
    
    placesList.appendChild(fragment);
    
    // 나머지 항목은 인터섹션 옵저버로 지연 로딩
    if (places.length > visiblePlacesCount) {
        setupInfiniteScroll(places, visiblePlacesCount, trip);
    }
}

function setupInfiniteScroll(places, startIndex, trip) {
    // 더 보기 버튼 추가
    const loadMoreBtn = document.createElement('button');
    loadMoreBtn.className = 'load-more-btn';
    loadMoreBtn.textContent = '더 보기';
    placesList.appendChild(loadMoreBtn);
    
    // 인터섹션 옵저버 설정
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                // 화면에 보이면 다음 항목 로드
                loadMorePlaces();
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.5 });
    
    observer.observe(loadMoreBtn);
    
    // 추가 항목 로드 함수
    function loadMorePlaces() {
        const fragment = document.createDocumentFragment();
        const endIndex = Math.min(startIndex + 30, places.length); // 30개씩 추가 로드
        
        for (let i = startIndex; i < endIndex; i++) {
            const listItem = createPlaceListItem(places[i], trip);
            fragment.appendChild(listItem);
        }
        
        // 더 보기 버튼 앞에 새 항목 삽입
        placesList.insertBefore(fragment, loadMoreBtn);
        
        // 인덱스 업데이트
        startIndex = endIndex;
        
        // 모든 항목을 로드했으면 더 보기 버튼 제거
        if (startIndex >= places.length) {
            loadMoreBtn.remove();
            observer.disconnect();
        } else {
            // 아직 더 있으면 계속 관찰
            observer.observe(loadMoreBtn);
        }
    }
}
```

### 3.3. 비동기 처리 최적화

오래 걸리는 작업을 Web Worker나 마이크로태스크로 분리하여 UI 반응성을 향상시킵니다.

```javascript
// data.js에 Web Worker 관리 코드 추가
let dataWorker = null;

function initDataWorker() {
    // Web Worker 지원 확인
    if (window.Worker) {
        try {
            dataWorker = new Worker('js/dataWorker.js');
            
            // 메시지 핸들러 설정
            dataWorker.onmessage = function(e) {
                const { type, data, error } = e.data;
                
                switch (type) {
                    case 'filterComplete':
                        // 필터링 결과 처리
                        handleFilterResults(data);
                        break;
                    case 'searchComplete':
                        // 검색 결과 처리
                        handleSearchResults(data);
                        break;
                    case 'error':
                        console.error('Web Worker 오류:', error);
                        showError('데이터 처리 중 오류가 발생했습니다.', error);
                        break;
                }
            };
            
            console.log('Data Worker 초기화 완료');
            return true;
        } catch (error) {
            console.error('Web Worker 초기화 실패:', error);
            return false;
        }
    } else {
        console.warn('Web Worker가 지원되지 않습니다. 대체 구현 사용');
        return false;
    }
}

// Web Worker 사용 예: 필터링 작업 위임
function filterPlacesByCategory(category, value, isChecked) {
    // Web Worker 사용 가능하면 워커에 위임
    if (dataWorker) {
        dataWorker.postMessage({
            type: 'filter',
            data: {
                category,
                value,
                isChecked,
                places: dataStore.places,
                activeFilters: collectActiveFilters()
            }
        });
        return;
    }
    
    // Worker 없으면 기존 필터링 로직 사용
    // ... 기존 코드 ...
}
```

### 3.4. 이미지 최적화

마커 이미지와 아이콘을 미리 로드하고 스프라이트 기법을 적용합니다.

```javascript
// 마커 이미지 프리로딩
const markerImageCache = {};

function preloadMarkerImages() {
    // 기본 마커 이미지 프리로드
    const baseColors = ['red', 'blue', 'green', 'purple', 'yellow', 'orange'];
    
    baseColors.forEach(color => {
        const img = new Image();
        img.src = `images/markers/${color}.png`;
        markerImageCache[color] = img;
    });
    
    // 라벨 기반 아이콘 프리로드
    if (dataStore.labelInfo) {
        Object.values(dataStore.labelInfo).forEach(label => {
            if (label.icon) {
                const img = new Image();
                img.src = `images/icons/${label.icon}.png`;
                markerImageCache[`icon_${label.icon}`] = img;
            }
        });
    }
    
    console.log('마커 이미지 프리로딩 완료');
}
```

## 4. 구현 계획 및 로드맵

### 4.1. 단계별 구현 계획

성능 개선을 점진적으로 적용하기 위한 단계별 구현 계획입니다.

#### 4.1.1. 1단계: 점진적 데이터 로딩 구현 (1주)

- 맵 인덱스 파일 생성 및 API 구현
- 테마/여행 데이터 온디맨드 로딩 구현
- 데이터 캐싱 메커니즘 구현

#### 4.1.2. 2단계: 마커 렌더링 최적화 (1주)

- 마커 클러스터링 구현
- 지연 마커 렌더링 적용
- 뷰포트 기반 마커 최적화

#### 4.1.3. 3단계: UI 반응성 개선 (1주)

- 장소 목록 무한 스크롤 구현
- 비동기 처리를 위한 Web Worker 구현
- 렌더링 최적화 및 불필요한 리플로우 제거

#### 4.1.4. 4단계: 이미지 및 리소스 최적화 (3일)

- 이미지 스프라이트 적용
- 리소스 프리로딩 및 캐싱
- 마커 이미지 최적화

#### 4.1.5. 5단계: 성능 측정 및 미세 조정 (3일)

- 성능 측정 툴 적용
- 병목 지점 식별 및 해결
- 최종 성능 테스트 및 사용자 피드백 수집

### 4.2. 호환성 고려사항

- IE11 등 구형 브라우저 지원을 위한 폴리필 적용
- 모바일 기기의 메모리 제약 고려
- 오프라인 사용을 위한 Service Worker 고려 (선택적)

### 4.3. 성능 모니터링 계획

- Chrome DevTools Performance 패널을 활용한 프로파일링
- Lighthouse를 통한 성능 점수 측정
- 실제 사용자 환경에서의 성능 데이터 수집

## 5. 결론 및 기대 효과

### 5.1. 기대 효과

- **초기 로딩 시간**: 70% 이상 감소 (전체 데이터 로드에서 필수 데이터만 로드로 전환)
- **메모리 사용량**: 40-50% 감소 (불필요한 데이터를 메모리에 유지하지 않음)
- **상호작용 반응성**: 지연 시간 90% 감소 (메인 스레드 차단 최소화)
- **대량 마커 처리**: 1000개 이상의 마커도 부드럽게 처리 가능

### 5.2. 제한 사항

- 일부 기능은 오프라인 상태에서 제한될 수 있음
- 초기 캐시 구축 전까지는 첫 사용 시 지연이 발생할 수 있음
- 매우 낮은 사양의 기기에서는 여전히 성능 제약이 있을 수 있음

### 5.3. 후속 개선 사항

- IndexedDB를 활용한 고급 오프라인 지원
- 사용자 패턴 분석을 통한 예측 프리로딩
- 백그라운드 동기화를 통한 데이터 업데이트
- WebAssembly를 활용한 고성능 데이터 처리 

## 6. 추가 성능 개선 제안

추가 성능 향상을 위한 최적화 방안입니다. 기존에 구현된 성능 개선 기법들에 더해 다음 사항들을 적용하면 사용자 경험을 더욱 향상시킬 수 있습니다.

### 6.1. 이미지 및 리소스 최적화

#### 6.1.1. 마커 이미지 최적화

```javascript
// js/map.js에 추가할 코드
function optimizeMarkerImages() {
    // 기존 preloadMarkerImages 함수 개선
    // 마커 이미지 크기 최적화 및 WebP 형식 사용 고려
    const markerTypes = ['default', 'food', 'attraction', 'shopping'];
    const imagePromises = [];
    
    markerTypes.forEach(type => {
        const imageUrl = `path/to/markers/${type}.webp`; // WebP 형식 사용
        const img = new Image();
        const promise = new Promise((resolve, reject) => {
            img.onload = () => {
                markerImageCache[type] = imageUrl;
                resolve();
            };
            img.onerror = reject;
        });
        
        img.src = imageUrl;
        imagePromises.push(promise);
    });
    
    return Promise.all(imagePromises)
        .catch(err => console.warn('일부 마커 이미지 로드 실패:', err));
}
```

#### 6.1.2. 이미지 형식 최적화

* 모든 마커와 아이콘 이미지를 WebP 형식으로 변환하여 파일 크기 20-30% 감소
* SVG 형식 사용으로 다양한 크기에서 선명한 아이콘 제공
* 이미지 크기 조정 및 최적화 자동화 스크립트 구현

### 6.2. 데이터 처리 최적화

#### 6.2.1. 장소 세부 정보 지연 로딩

```javascript
// js/data.js에 추가할 코드
async function loadPlaceDetails(placeId) {
    // 장소 세부 정보를 필요할 때만 지연 로드
    if (!placeDetailsCache[placeId]) {
        try {
            const response = await fetch(`data/places/${placeId}.json`);
            if (!response.ok) throw new Error('장소 데이터를 불러올 수 없습니다');
            
            const details = await response.json();
            placeDetailsCache[placeId] = details;
            return details;
        } catch (error) {
            console.error(`장소 세부정보 로드 실패 (ID: ${placeId}):`, error);
            return null;
        }
    }
    
    return placeDetailsCache[placeId];
}
```

#### 6.2.2. 고급 캐싱 시스템

```javascript
// 캐시 크기 제한 추가
const placeDetailsCache = {
    _cache: {},
    _maxSize: 50,
    _lruQueue: [],
    
    set: function(id, details) {
        // 캐시 크기 체크 및 필요시 가장 오래된 항목 제거
        if (this._lruQueue.length >= this._maxSize) {
            const oldestId = this._lruQueue.shift();
            delete this._cache[oldestId];
        }
        
        this._cache[id] = details;
        this._lruQueue.push(id);
    },
    
    get: function(id) {
        // 접근 시 LRU 큐 업데이트
        const idx = this._lruQueue.indexOf(id);
        if (idx > -1) {
            this._lruQueue.splice(idx, 1);
            this._lruQueue.push(id);
        }
        
        return this._cache[id];
    }
};
```

### 6.3. UI 렌더링 최적화

#### 6.3.1. 가상 스크롤링(Virtualized List) 구현

```javascript
// js/ui.js에 추가할 코드
function createVirtualizedPlacesList(places) {
    const listContainer = document.getElementById('places');
    const containerHeight = listContainer.clientHeight;
    const itemHeight = 50; // 각 항목의 높이(픽셀)
    const visibleItemsCount = Math.ceil(containerHeight / itemHeight);
    const totalItems = places.length;
    
    // 초기 렌더링은 화면에 보이는 항목만
    let startIndex = 0;
    let endIndex = Math.min(startIndex + visibleItemsCount + 5, totalItems); // 버퍼 포함
    
    // 실제 표시할 항목만 렌더링
    renderVisibleItems(places, startIndex, endIndex);
    
    // 스크롤 이벤트 핸들러
    listContainer.addEventListener('scroll', throttle(function() {
        const scrollTop = listContainer.scrollTop;
        const newStartIndex = Math.floor(scrollTop / itemHeight);
        const newEndIndex = Math.min(newStartIndex + visibleItemsCount + 5, totalItems);
        
        if (newStartIndex !== startIndex) {
            startIndex = newStartIndex;
            endIndex = newEndIndex;
            renderVisibleItems(places, startIndex, endIndex);
        }
    }, 100)); // 100ms 스로틀링
}

// 특정 범위의 항목만 렌더링하는 함수
function renderVisibleItems(places, startIndex, endIndex) {
    const listContainer = document.getElementById('places');
    const itemHeight = 50;
    const fragment = document.createDocumentFragment();
    
    // 전체 높이를 유지하는 패딩 요소
    const paddingTop = document.createElement('div');
    paddingTop.style.height = `${startIndex * itemHeight}px`;
    fragment.appendChild(paddingTop);
    
    // 실제 표시할 항목들
    for (let i = startIndex; i < endIndex; i++) {
        const place = places[i];
        const listItem = createPlaceListItem(place);
        fragment.appendChild(listItem);
    }
    
    // 하단 패딩
    const paddingBottom = document.createElement('div');
    const remainingItems = places.length - endIndex;
    paddingBottom.style.height = `${remainingItems * itemHeight}px`;
    fragment.appendChild(paddingBottom);
    
    // 기존 내용 대체
    listContainer.innerHTML = '';
    listContainer.appendChild(fragment);
}

// 스로틀 함수 구현
function throttle(func, wait) {
    let lastCall = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastCall >= wait) {
            lastCall = now;
            return func.apply(this, args);
        }
    };
}
```

#### 6.3.2. 로딩 상태 및 UI 반응성 개선

```javascript
// js/ui.js에 추가할 코드
function enhanceLoadingIndicator() {
    const loadingOverlay = document.createElement('div');
    loadingOverlay.className = 'loading-overlay';
    loadingOverlay.innerHTML = `
        <div class="loading-spinner">
            <div class="spinner"></div>
        </div>
        <div class="loading-text">데이터 로드 중...</div>
        <div class="loading-progress">
            <div class="progress-bar" id="loading-progress-bar"></div>
        </div>
    `;
    
    document.body.appendChild(loadingOverlay);
    
    // 진행 상황 업데이트 함수
    window.updateLoadingProgress = function(percent) {
        const progressBar = document.getElementById('loading-progress-bar');
        if (progressBar) {
            progressBar.style.width = `${percent}%`;
        }
    };
    
    // 로딩 표시 함수 개선
    window.showLoading = function(isLoading, message = '데이터 로드 중...') {
        loadingOverlay.style.display = isLoading ? 'flex' : 'none';
        loadingOverlay.querySelector('.loading-text').textContent = message;
        
        if (isLoading) {
            // 로딩 시작 시 프로그레스 바 초기화
            updateLoadingProgress(0);
        }
    };
}
```

### 6.4. 지도 렌더링 최적화

#### 6.4.1. 뷰포트 기반 선택적 렌더링

```javascript
// js/map.js에 추가할 코드
// 현재 화면에 보이는 영역만 렌더링하는 기능 추가
function setupViewportRendering() {
    let lastMapBounds = null;
    let lastZoomLevel = null;
    let renderTimeout = null;
    
    // 지도 이동 및 줌 이벤트에 대응
    kakao.maps.event.addListener(map, 'idle', function() {
        if (renderTimeout) {
            clearTimeout(renderTimeout);
        }
        
        // 짧은 지연 후 렌더링 (여러 이벤트 합치기)
        renderTimeout = setTimeout(() => {
            const currentBounds = map.getBounds();
            const currentZoom = map.getLevel();
            
            // 지도 영역이나 줌 레벨이 크게 변경된 경우에만 다시 렌더링
            if (!lastMapBounds || 
                !areBoundsSimilar(lastMapBounds, currentBounds) || 
                lastZoomLevel !== currentZoom) {
                
                renderVisibleMarkers();
                
                lastMapBounds = currentBounds;
                lastZoomLevel = currentZoom;
            }
        }, 150);
    });
}

// 두 경계 영역이 유사한지 확인 (작은 변화는 무시)
function areBoundsSimilar(bounds1, bounds2) {
    const sw1 = bounds1.getSouthWest();
    const ne1 = bounds1.getNorthEast();
    const sw2 = bounds2.getSouthWest();
    const ne2 = bounds2.getNorthEast();
    
    // 위도/경도 차이가 일정 이하면 유사하다고 판단
    const threshold = 0.01; // 약 1km 내외
    
    return (
        Math.abs(sw1.getLat() - sw2.getLat()) < threshold &&
        Math.abs(sw1.getLng() - sw2.getLng()) < threshold &&
        Math.abs(ne1.getLat() - ne2.getLat()) < threshold &&
        Math.abs(ne1.getLng() - ne2.getLng()) < threshold
    );
}

// 현재 지도 영역에 보이는 마커만 렌더링
function renderVisibleMarkers() {
    // 현재 지도 경계 가져오기
    const bounds = map.getBounds();
    
    // 모든 마커 숨기기
    markers.forEach(marker => {
        if (marker instanceof kakao.maps.Marker) {
            marker.setMap(null);
        } else if (marker instanceof kakao.maps.CustomOverlay) {
            marker.setMap(null);
        }
    });
    
    // 화면에 보이는 마커만 표시
    const visibleMarkers = markers.filter(marker => {
        let position;
        
        if (marker instanceof kakao.maps.Marker) {
            position = marker.getPosition();
        } else if (marker instanceof kakao.maps.CustomOverlay) {
            // 커스텀 오버레이의 경우 장소 위치 가져오기
            const place = marker.place;
            if (!place || !place.location) return false;
            
            position = new kakao.maps.LatLng(place.location.lat, place.location.lng);
        } else {
            return false;
        }
        
        // 현재 지도 영역 내에 있는지 확인
        return bounds.contain(position);
    });
    
    // 보이는 마커만 지도에 추가
    visibleMarkers.forEach(marker => {
        if (marker instanceof kakao.maps.Marker) {
            marker.setMap(map);
        } else if (marker instanceof kakao.maps.CustomOverlay) {
            marker.setMap(map);
        }
    });
    
    console.log(`화면에 보이는 마커: ${visibleMarkers.length}/${markers.length}`);
}
```

### 6.5. 오프라인 지원 및 지속성

#### 6.5.1. 서비스 워커 구현

```javascript
// 새 파일: js/service-worker.js
const CACHE_NAME = 'travel-map-cache-v1';
const OFFLINE_URL = 'offline.html';

const urlsToCache = [
    '/',
    '/index.html',
    '/css/style.css',
    '/css/responsive.css',
    '/js/data.js',
    '/js/map.js',
    '/js/ui.js',
    '/js/dataWorker.js',
    '/data/labels.json',
    // 자주 사용되는 이미지, 아이콘 등도 추가
];

// 서비스 워커 설치 시 캐시 초기화
self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => {
                console.log('캐시 초기화');
                return cache.addAll(urlsToCache);
            })
    );
});

// 캐시 우선 전략으로 리소스 가져오기
self.addEventListener('fetch', event => {
    // 네트워크 요청 전에 캐시 확인
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // 캐시에 있으면 캐시된 버전 반환
                if (response) {
                    return response;
                }
                
                // 없으면 네트워크 요청
                return fetch(event.request)
                    .then(response => {
                        // 유효한 응답인지 확인
                        if (!response || response.status !== 200 || response.type !== 'basic') {
                            return response;
                        }
                        
                        // 응답 복제 (스트림은 한 번만 사용 가능)
                        const responseToCache = response.clone();
                        
                        // 응답을 캐시에 저장
                        caches.open(CACHE_NAME)
                            .then(cache => {
                                cache.put(event.request, responseToCache);
                            });
                        
                        return response;
                    })
                    .catch(error => {
                        // 오프라인 상태이고 HTML 요청인 경우 오프라인 페이지 제공
                        if (event.request.headers.get('accept').includes('text/html')) {
                            return caches.match(OFFLINE_URL);
                        }
                    });
            })
    );
});

// 서비스 워커 활성화 시 이전 캐시 정리
self.addEventListener('activate', event => {
    event.waitUntil(
        caches.keys().then(cacheNames => {
            return Promise.all(
                cacheNames.map(cacheName => {
                    if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
});
```

서비스 워커 등록 코드:

```javascript
// index.html의 <script> 부분에 추가
// 서비스 워커 등록
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/js/service-worker.js')
            .then(registration => {
                console.log('서비스 워커 등록 성공:', registration.scope);
            })
            .catch(error => {
                console.error('서비스 워커 등록 실패:', error);
            });
    });
}
```

#### 6.5.2. IndexedDB를 활용한 데이터 영구 저장

```javascript
// js/data.js에 추가할 코드
// IndexedDB 초기화
function initDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('TravelMapDB', 1);
        
        request.onerror = function(event) {
            console.error('IndexedDB 열기 실패:', event);
            resolve(false); // 오류가 있어도 앱은 계속 작동해야 함
        };
        
        request.onupgradeneeded = function(event) {
            const db = event.target.result;
            
            // 장소 저장소
            if (!db.objectStoreNames.contains('places')) {
                const placeStore = db.createObjectStore('places', { keyPath: 'id' });
                placeStore.createIndex('themeId', 'themeId', { multiEntry: true });
                placeStore.createIndex('tripId', 'tripId', { multiEntry: true });
                placeStore.createIndex('labels', 'labels', { multiEntry: true });
            }
            
            // 테마 저장소
            if (!db.objectStoreNames.contains('themes')) {
                db.createObjectStore('themes', { keyPath: 'id' });
            }
            
            // 여행 저장소
            if (!db.objectStoreNames.contains('trips')) {
                db.createObjectStore('trips', { keyPath: 'id' });
            }
        };
        
        request.onsuccess = function(event) {
            const db = event.target.result;
            console.log('IndexedDB 초기화 성공');
            resolve(true);
        };
    });
}
```

### 6.6. 성능 모니터링 및 분석

#### 6.6.1. 웹 성능 측정 도구 추가

```javascript
// js/performance.js (새 파일)
// 성능 측정 및 모니터링 도구
const performanceMonitor = {
    marks: {},
    
    // 성능 측정 시작
    start: function(name) {
        const startTime = performance.now();
        this.marks[name] = { start: startTime };
        
        // Performance API 마크 추가
        performance.mark(`${name}-start`);
        
        return startTime;
    },
    
    // 성능 측정 종료
    end: function(name) {
        if (!this.marks[name] || !this.marks[name].start) {
            console.warn(`${name} 측정이 시작되지 않았습니다.`);
            return;
        }
        
        const endTime = performance.now();
        this.marks[name].end = endTime;
        this.marks[name].duration = endTime - this.marks[name].start;
        
        // Performance API 마크 및 측정 추가
        performance.mark(`${name}-end`);
        performance.measure(name, `${name}-start`, `${name}-end`);
        
        console.log(`성능 측정 - ${name}: ${this.marks[name].duration.toFixed(2)}ms`);
        
        // 느린 작업 감지
        if (this.marks[name].duration > 1000) { // 1초 이상 소요된 작업
            console.warn(`성능 경고 - ${name}이(가) ${this.marks[name].duration.toFixed(2)}ms 소요됨`);
            
            // 성능 문제를 서버에 보고하거나 로컬 로그에 기록할 수 있음
        }
        
        return this.marks[name].duration;
    },
    
    // 모든 측정 결과 가져오기
    getAll: function() {
        return this.marks;
    },
    
    // 특정 측정 결과 가져오기
    get: function(name) {
        return this.marks[name];
    },
    
    // 모든 측정 결과 리셋
    reset: function() {
        this.marks = {};
        performance.clearMarks();
        performance.clearMeasures();
    }
};
```

### 6.7. 추가 최적화 로드맵

#### 6.7.1. 단계별 추가 구현 계획

1. **6단계: 고급 데이터 캐싱 구현 (1주)**
   - IndexedDB 활용 영구 데이터 캐싱
   - 자주 사용하는 데이터 예측 프리로딩
   - 동적 메모리 관리 최적화

2. **7단계: 오프라인 지원 기능 구현 (1주)**
   - 서비스 워커 구현
   - 오프라인 모드 UI 추가
   - 백그라운드 동기화 기능

3. **8단계: 고급 UI 최적화 (1주)**
   - 가상 스크롤링 구현
   - 애니메이션 최적화
   - 입력 지연 최소화

4. **9단계: 향상된 모니터링 (3일)**
   - 사용자 환경 성능 데이터 수집
   - 자동 성능 보고 시스템
   - 실시간 성능 문제 감지

### 6.8. 추가 개선 기대 효과

- **대규모 데이터 처리**: 5,000개 이상의 장소 데이터도 원활하게 처리
- **오프라인 사용성**: 네트워크 연결 없이도 기본 기능 사용 가능
- **첫 방문 사용자 경험**: 첫 로딩 시간 추가 20% 단축
- **메모리 사용 최적화**: 이전 대비 추가 30% 메모리 사용량 감소
- **모바일 성능**: 저사양 모바일 기기에서도 60fps 이상 유지

### 6.9. 기술 부채 및 제약 사항

- 일부 기능은 최신 브라우저 API에 의존하므로 폴리필 필요
- 오프라인 모드에서는 일부 지도 타일이 제한될 수 있음
- 대용량 데이터 캐싱은 기기 저장소 제약에 따라 제한될 수 있음
- 구형 브라우저에서는 일부 최적화 기법이 적용되지 않을 수 있음 